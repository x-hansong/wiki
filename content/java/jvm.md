---
title: JVM 垃圾收集与内存分配
layout: page
date: 2016-03-17
---
[TOC]

## 运行时数据区
![运行时数据区](http://7xjtfr.com1.z0.glb.clouddn.com/41376821593549120.jpg)

1. 程序计数器（线程私有）

    当前线程所执行的字节码的行号指示器。

2. 栈（线程私有）

    每个方法执行时会创建一个栈帧用于存储局部变量等信息。

3. 本地方法栈（类似栈）

    为虚拟机使用到的 Native 方法服务。

4. 堆（线程共享）

    存放对象实例，是垃圾收集器管理的主要区域。

5. 方法区（线程共享）

    用于存储已经被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。（也被人称为“永久代”）
    运行时常量池位于这个区域，用于存放编译期生成的各种字面量和符号引用。

## 垃圾回收

### 回收的对象
堆中的对象
#### 可达性分析算法
从 GC Roots 出发，没有跟 GC Roots 引用链相连的对象可回收。

#### GC Roots 选择
1. 栈中引用的对象
2. 方法区（永久代）中引用的对象
3. 本地方法栈中引用的对象

#### 引用

1. **强引用**：不会被回收
2. **软引用**：内存不足时才会被回收
3. **弱引用**：只能生存到下一次垃圾收集发生之前
4. **虚引用**：被回收时能收到一个系统通知

### 回收的方法

#### 标记清除算法
标记需要回收的对象，标记完成之后清除被标记对象。

缺点：效率低，空间碎片
#### 复制算法
把内存空间分为两块，只使用其中的一块，满了之后把存活的对象复制到另一块，清除本块的对象。

缺点：存活率大时需要较多复制操作。

#### 标记整理算法
标记回收对象之后，把它们移动到一端，清除端边界外的对象。

#### 分代收集算法
把堆分为两块：

1. **新生代**：使用复制算法。（包括一个Eden空间和两个survivor空间）
2. **老年代**：使用标记清除或标记整理算法。

### 垃圾收集器
![垃圾收集器](http://7xjtfr.com1.z0.glb.clouddn.com/20130925212623125.jpg)

1. Serial: 单线程收集器，工作时暂停其他工作线程。常用于Client模式，在新生代采用复制算法，在老生代使用标记-整理算法
2. ParNew: Serial 多线程版本，并行收集器，主要用于新生代收集。与CMS收集器配合成为现在最常用的server收集器
3. Parallel Scavenge 并行收集器，吞吐量（用户代码运行时间/用户代码运行时间+垃圾收集时间）优先。
4. Serial Old: Serial 老年代版本，单线程，使用“标记整理”算法
5. Parallel Old: Parallel Scavenge 的老年代版本。
6. CMS: 并发收集，低停顿，基于“标记-清除”算法。

    1. 初始标记: 暂停工作线程，标记 GC Roots 能直接关联到的对象。
    2. 并发标记：与工作线程并发，进行 GC Roots Tracing
    3. 重新标记：暂停工作线程，修正并发标记过程中发生变动的对象。
    4. 并发清除

    缺点：

    1. 对CPU资源非常敏感
    2. 不能处理浮动垃圾（标记过程后出现的垃圾）
    3. 产生空间碎片

7. G1（Garbage First)

    特点：

    1. 并行与并发
    2. 分代收集（概念上分代，实际的内存布局不再是新生代，老年代隔离）
    3. 空间整合（基于“标记整理”算法）
    4. 可预测的停顿
    5. 分 Region 收集，根据允许收集的时间，优先回收价值最大的 Region

    过程：

    1. 初始标记
    2. 并发标记
    3. 最终标记：并行
    4. 筛选回收：并行

## 内存分配
- 新生代GC（Minor GC）：发生在新生代的垃圾收集，速度比较块。
- 老年代GC （Major GC/Full GC）：发生在老年代的垃圾收集，速度比较慢。

1. 首先向eden区申请分配空间，如果空间够，就直接进行分配，否则进行一次Minor GC。
2. Minor GC 首先会对Eden区的对象进行标记，标记出来存活的对象。然后把存活的对象copy到From空间。（标记-复制）

    1. 如果From空间足够，则回收eden区可回收的对象。
    2. 如果from内存空间不够，则把From空间存活的对象复制到To区，
    3. 如果TO区的内存空间也不够的话，则把To区存活的对象复制到老年代。

3. 如果老年代空间也不够（或者达到触发老年年垃圾回收条件的话）则触发一次full GC。

### Full GC 触发条件

1、System.gc()方法的调用

此方法的调用是建议JVM进行Full GC,虽然只是建议而非一定,但很多情况下它会触发 Full GC,从而增加Full GC的频率,也即增加了间歇性停顿的次数。强烈影响系建议能不使用此方法就别使用，让虚拟机自己去管理它的内存，可通过通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc。

2、老年代空间不足

老年代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出如下错误：
java.lang.OutOfMemoryError: Java heap space
为避免以上两种状况引起的Full GC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。

3、永生区空间不足

JVM规范中运行时数据区域中的方法区，在HotSpot虚拟机中又被习惯称为永生代或者永生区，Permanet Generation中存放的为一些class的信息、常量、静态变量等数据，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下也会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息：
java.lang.OutOfMemoryError: PermGen space
为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。

4、CMS GC时出现promotion failed和concurrent mode failure

对于采用CMS进行老年代GC的程序而言，尤其要注意GC日志中是否有promotion failed和concurrent mode failure两种状况，当这两种状况出现时可能
会触发Full GC。
promotion failed是在进行Minor GC时，survivor space放不下、对象只能放入老年代，而此时老年代也放不下造成的；concurrent mode failure是在
执行CMS GC的过程中同时有对象要放入老年代，而此时老年代空间不足造成的（有时候“空间不足”是CMS GC时当前的浮动垃圾过多导致暂时性的空间不足触发Full GC）。
对措施为：增大survivor space、老年代空间或调低触发并发GC的比率，但在JDK 5.0+、6.0+的版本中有可能会由于JDK的bug29导致CMS在remark完毕
后很久才触发sweeping动作。对于这种状况，可通过设置-XX: CMSMaxAbortablePrecleanTime=5（单位为ms）来避免。

5、统计得到的Minor GC晋升到旧生代的平均大小大于老年代的剩余空间

这是一个较为复杂的触发情况，Hotspot为了避免由于新生代对象晋升到旧生代导致旧生代空间不足的现象，在进行Minor GC时，做了一个判断，如果之
前统计所得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间，那么就直接触发Full GC。
例如程序第一次触发Minor GC后，有6MB的对象晋升到旧生代，那么当下一次Minor GC发生时，首先检查旧生代的剩余空间是否大于6MB，如果小于6MB，
则执行Full GC。
当新生代采用PS GC时，方式稍有不同，PS GC是在Minor GC后也会检查，例如上面的例子中第一次Minor GC后，PS GC会检查此时旧生代的剩余空间是否
大于6MB，如小于，则触发对旧生代的回收。
除了以上4种状况外，对于使用RMI来进行RPC或管理的Sun JDK应用而言，默认情况下会一小时执行一次Full GC。可通过在启动时通过- java -
Dsun.rmi.dgc.client.gcInterval=3600000来设置Full GC执行的间隔时间或通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc。

6、堆中分配很大的对象

所谓大对象，是指需要大量连续内存空间的java对象，例如很长的数组，此种对象会直接进入老年代，而老年代虽然有很大的剩余空间，但是无法找到足够大的连续空间来分配给当前对象，此种情况就会触发JVM进行Full GC。
为了解决这个问题，CMS垃圾收集器提供了一个可配置的参数，即-XX:+UseCMSCompactAtFullCollection开关参数，用于在“享受”完Full GC服务之后额外免费赠送一个碎片整理的过程，内存整理的过程无法并发的，空间碎片问题没有了，但提顿时间不得不变长了，JVM设计者们还提供了另外一个参数 -XX:CMSFullGCsBeforeCompaction,这个参数用于设置在执行多少次不压缩的Full GC后,跟着来一次带压缩的。

### 内存分配策略

1. 对象优先在Eden分配
2. 大对象直接进入老年代
3. 长期存活的对象将进入老年代：对象年龄达到设定值
4. 动态对象年龄判定：如果Survivor空间中相同年龄所有对象的大小总和大于Survivor空间的一半，大于等于该年龄的对象进入老年代
5. 空间分配担保：发生Minor GC之前，虚拟机会检查老年代的可用空间是否大于新生代所有对象的空间，条件成立则Minor GC是安全的

### 内存布局
![内存布局](http://7xjtfr.com1.z0.glb.clouddn.com/06524e23ef9136970be290e3732c0066_thumb.jpg)