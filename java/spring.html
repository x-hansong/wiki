<!DOCTYPE HTML>
<html>
  <head>
    <link rel="Stylesheet" type="text/css" href="/static/css/style.css">
    <link rel="Stylesheet" type="text/css" href="/static/css/tango.css">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Atom feed">
    <title>Spring 实践 - Wiki | HanSong</title>
    <meta name="keywords" content="wiki, markdown, linux, c, java, python, qemu"/>
    <meta name="description" content="HanSong's personal wiki, recording my little thoughts"/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  </head>

  <body>
    <div id="container">
      
<div id="header">
  <div class="post-nav"><a href="/">Home</a>&nbsp;&#187;&nbsp;<a href="/#java">java</a>&nbsp;&#187;&nbsp;Spring 实践
    <span class="updated">Updated&nbsp;
      2015-10-19
    </span></div>
</div>
<div class="clearfix"></div>

<div class="page_title">Spring 实践</div>

  <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#spring">Spring 默认配置</a></li>
<li><a href="#spring-data-jpa">Spring Data JPA映射表名大小写不敏感</a><ul>
<li><a href="#_1">问题描述</a></li>
<li><a href="#_2">解决办法</a></li>
<li><a href="#_3">问题原因</a></li>
</ul>
</li>
<li><a href="#spring-data-jpa-repository">Spring Data JPA 自定义 Repository</a></li>
<li><a href="#mysql-8">Mysql 8 小时自动断开连接</a></li>
<li><a href="#spring-data-jpa-hibernate-lazy-fetch">Spring data jpa 中 Hibernate 的 Lazy Fetch 失效问题解决</a></li>
<li><a href="#spring-initbindervalidators">Spring 使用InitBinder绑定Validators</a></li>
<li><a href="#spring_1">Spring 事务</a><ul>
<li><a href="#transactional">@Transactional</a></li>
<li><a href="#_4">事务的传播</a></li>
</ul>
</li>
</ul>
</div>
<h2 id="spring">Spring 默认配置</h2>
<p>Spring 有很多的默认行为，有时候会被它的默认行为搞得一头雾水，下面记录坑过我的默认配置。</p>
<ol>
<li>Spring 中使用 JUnit @Test 注解的函数，如果加上 @Transactional 启动事务，默认在函数结束时会自动回滚。这样的话很方便测试，而不会对数据库有副作用。（但是我不知道的时候，以为出了bug，查了好久才发现原因。）</li>
</ol>
<h2 id="spring-data-jpa">Spring Data JPA映射表名大小写不敏感</h2>
<blockquote>
<p>add at 2015-10-19</p>
</blockquote>
<h3 id="_1">问题描述</h3>
<p>使用<code>@Table(name="User")</code>指定表名的时候,表名会被映射为<code>user</code>,结果执行sql语句就会报找不到表名的错误.</p>
<h3 id="_2">解决办法</h3>
<p>改变hibernate的naming-strategy</p>
<p>我使用的是spring boot,所以只需要在<code>application.properties</code>中加入</p>
<div class="hlcode"><pre><span class="n">spring</span><span class="p">.</span><span class="n">jpa</span><span class="p">.</span><span class="n">hibernate</span><span class="p">.</span><span class="n">naming</span><span class="o">-</span><span class="n">strategy</span><span class="o">=</span><span class="n">org</span><span class="p">.</span><span class="n">hibernate</span><span class="p">.</span><span class="n">cfg</span><span class="p">.</span><span class="n">DefaultNamingStrategy</span>
</pre></div>


<h3 id="_3">问题原因</h3>
<p>spring默认使用的hibernate naming-strategy是大小写不敏感的.</p>
<h2 id="spring-data-jpa-repository">Spring Data JPA 自定义 Repository</h2>
<p>根据官方文档的描述,默认的自定义行为需要三步:</p>
<ul>
<li>
<p>声明一个自定义接口</p>
<div class="hlcode"><pre><span class="n">interface</span> <span class="n">UserRepositoryCustom</span> <span class="p">{</span>
    <span class="n">public</span> <span class="kt">void</span> <span class="n">someCustomMethod</span><span class="p">(</span><span class="n">User</span> <span class="n">user</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


</li>
<li>
<p>实现上面的接口</p>
<div class="hlcode"><pre><span class="n">class</span> <span class="n">UserRepositoryImpl</span> <span class="n">implements</span> <span class="n">UserRepositoryCustom</span> <span class="p">{</span>
    <span class="n">public</span> <span class="kt">void</span> <span class="n">someCustomMethod</span><span class="p">(</span><span class="n">User</span> <span class="n">user</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Your custom implementation</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


</li>
<li>
<p>同时继承内置的 Repository 和自定义的接口</p>
<div class="hlcode"><pre><span class="n">public</span> <span class="n">interface</span> <span class="n">UserRepository</span> <span class="n">extends</span> <span class="n">CrudRepository</span><span class="o">&lt;</span><span class="n">User</span><span class="p">,</span> <span class="n">Long</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">UserRepositoryCustom</span> <span class="p">{</span>
    <span class="c1">// Declare query methods here</span>
<span class="p">}</span>
</pre></div>


</li>
</ul>
<p>值得注意的是,自定义的接口一定要以 <code>RepositoryCustom</code> 为后缀,自定义接口的实现一定要以 <code>RepositoryImpl</code> 作为后缀.Spring 会根据名字进行配置.</p>
<p>当然,以上是默认的行为,你可以自己配置来更改默认的命名规范.详细操作查看官方文档.</p>
<h2 id="mysql-8">Mysql 8 小时自动断开连接</h2>
<p>MySQL 的默认设置下，当一个连接的空闲时间超过8小时后，MySQL 就会断开该连接.</p>
<p>解决方法是定时发送请求,连接就会重置连接时间.具体在 Spring Boot 的配置文件 <code>application.properties</code> 加入:</p>
<div class="hlcode"><pre><span class="n">spring</span><span class="p">.</span><span class="n">datasource</span><span class="p">.</span><span class="n">test</span><span class="o">-</span><span class="n">on</span><span class="o">-</span><span class="n">borrow</span><span class="o">=</span><span class="nb">true</span>
<span class="n">spring</span><span class="p">.</span><span class="n">datasource</span><span class="p">.</span><span class="n">validation</span><span class="o">-</span><span class="n">query</span><span class="o">=</span><span class="n">SELECT</span> <span class="mi">1</span>
</pre></div>


<h2 id="spring-data-jpa-hibernate-lazy-fetch">Spring data jpa 中 Hibernate 的 Lazy Fetch 失效问题解决</h2>
<p>Spring data jpa 的底层是 Hibernate，因为 Repository 接口方法的查询完成每次都会关闭 Session，所以 Hibernate 的 Lazy Fetch 会失败，解决办法是利用 Spring 的Transaction 来使 Repository 的查询方法不关闭 Session。具体操作是在需要使用 Lazy Fetch 的方法加上 <code>@Transaction</code> 的注解。</p>
<div class="hlcode"><pre><span class="p">@</span><span class="nx">Transactional</span>
<span class="k">public</span> <span class="nf">void</span> <span class="nx">testUser</span><span class="p">(){</span>
    <span class="nb">User</span> <span class="n">user</span> <span class="o">=</span> <span class="nx">userRepository.findByName</span><span class="p">(</span><span class="s2">&quot;hansong&quot;</span><span class="p">);</span>
    <span class="nb">Set</span><span class="o">&lt;</span><span class="nb">User</span><span class="o">&gt;</span> <span class="n">users</span> <span class="o">=</span> <span class="nx">user.getFriendList</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>


<h2 id="spring-initbindervalidators">Spring 使用InitBinder绑定Validators</h2>
<div class="hlcode"><pre><span class="err">@</span><span class="n">InitBinder</span><span class="p">(</span><span class="s">&quot;userDTO&quot;</span><span class="p">)</span><span class="c1">//这里要填需要校验的变量名</span>
<span class="n">protected</span> <span class="kt">void</span> <span class="n">initUserDTOBinder</span><span class="p">(</span><span class="n">WebDataBinder</span> <span class="n">binder</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">binder</span><span class="p">.</span><span class="n">addValidators</span><span class="p">(</span><span class="n">new</span> <span class="n">UserDTOValidator</span><span class="p">());</span>
<span class="p">}</span>

<span class="err">@</span><span class="n">InitBinder</span><span class="p">(</span><span class="s">&quot;codePhoneDTO&quot;</span><span class="p">)</span>
<span class="n">protected</span> <span class="kt">void</span> <span class="n">initCodePhoneDTOBinder</span><span class="p">(</span><span class="n">WebDataBinder</span> <span class="n">binder</span><span class="p">){</span>
    <span class="n">binder</span><span class="p">.</span><span class="n">addValidators</span><span class="p">(</span><span class="n">new</span> <span class="n">CodePhoneDTOValidator</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>


<p>如果<code>@InitBinder</code>不填变量名，默认是对所有 SpringMVC 输入变量进行校验。</p>
<p><code>Validator</code>需要实现<code>org.springframework.validation.Validator</code>接口。</p>
<h2 id="spring_1">Spring 事务</h2>
<h3 id="transactional">@Transactional</h3>
<p>在单独使用不带任何参数的@Transactional 注释时，传播模式要设置为 REQUIRED，只读标志设置为 false，事务隔离级别设置为 READ_COMMITTED，而且事务不会针对受控异常（checked exception）回滚。</p>
<h3 id="_4">事务的传播</h3>
<p>所谓事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播。Spring 支持 7 种事务传播行为：</p>
<ol>
<li>
<p>PROPAGATION_REQUIRED（加入已有事务）</p>
<p>尝试加入已经存在的事务中，如果没有则开启一个新的事务。</p>
</li>
<li>
<p>RROPAGATION_REQUIRES_NEW（独立事务）</p>
<p>挂起当前存在的事务，并开启一个全新的事务，新事务与已存在的事务之间彼此没有关系。</p>
</li>
<li>
<p>PROPAGATION_NESTED（嵌套事务）</p>
<p>在当前事务上开启一个子事务（Savepoint），如果递交主事务。那么连同子事务一同递交。如果递交子事务则保存点之前的所有事务都会被递交。</p>
</li>
<li>
<p>PROPAGATION_SUPPORTS（跟随环境）</p>
<p>是指 Spring 容器中如果当前没有事务存在，就以非事务方式执行；如果有，就使用当前事务。</p>
</li>
<li>
<p>PROPAGATION_NOT_SUPPORTED（非事务方式）</p>
<p>是指如果存在事务则将这个事务挂起，并使用新的数据库连接。新的数据库连接不使用事务。</p>
</li>
<li>
<p>PROPAGATION_NEVER（排除事务）</p>
<p>当存在事务时抛出异常，否则就已非事务方式运行。</p>
</li>
<li>
<p>PROPAGATION_MANDATORY（需要事务）</p>
<p>如果不存在事务就抛出异常，否则就已事务方式运行。</p>
</li>
</ol>
<p><em>挂起事务：</em></p>
<p>所谓“挂起”指的是将当前线程使用的数据库连接，暂时保存起来不在使用。取而代之的是一个新的数据库库连接。</p>
<p>与挂起相对应的还有一个“恢复事务”，它们的操作是成对出现的。恢复就是将当前数据库连接释放掉，然后将以前挂起的那个数据库连接重新设为当前数据库连接。</p>
    </div>
    <div id="footer">
      <span>
        <p>Copyright © 2017 HanSong Xiao.
        Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1256629854'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/z_stat.php%3Fid%3D1256629854%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script></p>
        <p>Site Generated 2017-07-16 23:42:46</p>
      </span>
    </div>
  </body>
</html>