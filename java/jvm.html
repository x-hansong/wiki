<!DOCTYPE HTML>
<html>
  <head>
    <link rel="Stylesheet" type="text/css" href="/static/css/style.css">
    <link rel="Stylesheet" type="text/css" href="/static/css/tango.css">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Atom feed">
    <title>JVM 垃圾收集与内存分配 - Wiki | HanSong</title>
    <meta name="keywords" content="wiki, markdown, linux, c, java, python, qemu"/>
    <meta name="description" content="HanSong's personal wiki, recording my little thoughts"/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  </head>

  <body>
    <div id="container">
      
<div id="header">
  <div class="post-nav"><a href="/">Home</a>&nbsp;&#187;&nbsp;<a href="/#java">java</a>&nbsp;&#187;&nbsp;JVM 垃圾收集与内存分配
    <span class="updated">Updated&nbsp;
      2016-03-17
    </span></div>
</div>
<div class="clearfix"></div>

<div class="page_title">JVM 垃圾收集与内存分配</div>

  <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#_1">运行时数据区</a></li>
<li><a href="#_2">垃圾回收</a><ul>
<li><a href="#_3">回收的对象</a><ul>
<li><a href="#_4">可达性分析算法</a></li>
<li><a href="#gc-roots">GC Roots 选择</a></li>
<li><a href="#_5">引用</a></li>
</ul>
</li>
<li><a href="#_6">回收的方法</a><ul>
<li><a href="#_7">标记清除算法</a></li>
<li><a href="#_8">复制算法</a></li>
<li><a href="#_9">标记整理算法</a></li>
<li><a href="#_10">分代收集算法</a></li>
</ul>
</li>
<li><a href="#_11">垃圾收集器</a></li>
</ul>
</li>
<li><a href="#_12">内存分配</a><ul>
<li><a href="#full-gc">Full GC 触发条件</a></li>
<li><a href="#_13">内存分配策略</a></li>
<li><a href="#_14">内存布局</a></li>
</ul>
</li>
</ul>
</div>
<h2 id="_1">运行时数据区</h2>
<p><img alt="运行时数据区" src="http://7xjtfr.com1.z0.glb.clouddn.com/41376821593549120.jpg" /></p>
<ol>
<li>
<p>程序计数器（线程私有）</p>
<p>当前线程所执行的字节码的行号指示器。</p>
</li>
<li>
<p>栈（线程私有）</p>
<p>每个方法执行时会创建一个栈帧用于存储局部变量等信息。</p>
</li>
<li>
<p>本地方法栈（类似栈）</p>
<p>为虚拟机使用到的 Native 方法服务。</p>
</li>
<li>
<p>堆（线程共享）</p>
<p>存放对象实例，是垃圾收集器管理的主要区域。</p>
</li>
<li>
<p>方法区（线程共享）</p>
<p>用于存储已经被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。（也被人称为“永久代”）
运行时常量池位于这个区域，用于存放编译期生成的各种字面量和符号引用。</p>
</li>
</ol>
<h2 id="_2">垃圾回收</h2>
<h3 id="_3">回收的对象</h3>
<p>堆中的对象</p>
<h4 id="_4">可达性分析算法</h4>
<p>从 GC Roots 出发，没有跟 GC Roots 引用链相连的对象可回收。</p>
<h4 id="gc-roots">GC Roots 选择</h4>
<ol>
<li>栈中引用的对象</li>
<li>方法区（永久代）中引用的对象</li>
<li>本地方法栈中引用的对象</li>
</ol>
<h4 id="_5">引用</h4>
<ol>
<li><strong>强引用</strong>：不会被回收</li>
<li><strong>软引用</strong>：内存不足时才会被回收</li>
<li><strong>弱引用</strong>：只能生存到下一次垃圾收集发生之前</li>
<li><strong>虚引用</strong>：被回收时能收到一个系统通知</li>
</ol>
<h3 id="_6">回收的方法</h3>
<h4 id="_7">标记清除算法</h4>
<p>标记需要回收的对象，标记完成之后清除被标记对象。</p>
<p>缺点：效率低，空间碎片</p>
<h4 id="_8">复制算法</h4>
<p>把内存空间分为两块，只使用其中的一块，满了之后把存活的对象复制到另一块，清除本块的对象。</p>
<p>缺点：存活率大时需要较多复制操作。</p>
<h4 id="_9">标记整理算法</h4>
<p>标记回收对象之后，把它们移动到一端，清除端边界外的对象。</p>
<h4 id="_10">分代收集算法</h4>
<p>把堆分为两块：</p>
<ol>
<li><strong>新生代</strong>：使用复制算法。（包括一个Eden空间和两个survivor空间）</li>
<li><strong>老年代</strong>：使用标记清除或标记整理算法。</li>
</ol>
<h3 id="_11">垃圾收集器</h3>
<p><img alt="垃圾收集器" src="http://7xjtfr.com1.z0.glb.clouddn.com/20130925212623125.jpg" /></p>
<ol>
<li>Serial: 单线程收集器，工作时暂停其他工作线程。常用于Client模式，在新生代采用复制算法，在老生代使用标记-整理算法</li>
<li>ParNew: Serial 多线程版本，并行收集器，主要用于新生代收集。与CMS收集器配合成为现在最常用的server收集器</li>
<li>Parallel Scavenge 并行收集器，吞吐量（用户代码运行时间/用户代码运行时间+垃圾收集时间）优先。</li>
<li>Serial Old: Serial 老年代版本，单线程，使用“标记整理”算法</li>
<li>Parallel Old: Parallel Scavenge 的老年代版本。</li>
<li>
<p>CMS: 并发收集，低停顿，基于“标记-清除”算法。</p>
<ol>
<li>初始标记: 暂停工作线程，标记 GC Roots 能直接关联到的对象。</li>
<li>并发标记：与工作线程并发，进行 GC Roots Tracing</li>
<li>重新标记：暂停工作线程，修正并发标记过程中发生变动的对象。</li>
<li>并发清除</li>
</ol>
<p>缺点：</p>
<ol>
<li>对CPU资源非常敏感</li>
<li>不能处理浮动垃圾（标记过程后出现的垃圾）</li>
<li>产生空间碎片</li>
</ol>
</li>
<li>
<p>G1（Garbage First)</p>
<p>特点：</p>
<ol>
<li>并行与并发</li>
<li>分代收集（概念上分代，实际的内存布局不再是新生代，老年代隔离）</li>
<li>空间整合（基于“标记整理”算法）</li>
<li>可预测的停顿</li>
<li>分 Region 收集，根据允许收集的时间，优先回收价值最大的 Region</li>
</ol>
<p>过程：</p>
<ol>
<li>初始标记</li>
<li>并发标记</li>
<li>最终标记：并行</li>
<li>筛选回收：并行</li>
</ol>
</li>
</ol>
<h2 id="_12">内存分配</h2>
<ul>
<li>新生代GC（Minor GC）：发生在新生代的垃圾收集，速度比较块。</li>
<li>
<p>老年代GC （Major GC/Full GC）：发生在老年代的垃圾收集，速度比较慢。</p>
</li>
<li>
<p>首先向eden区申请分配空间，如果空间够，就直接进行分配，否则进行一次Minor GC。</p>
</li>
<li>
<p>Minor GC 首先会对Eden区的对象进行标记，标记出来存活的对象。然后把存活的对象copy到From空间。（标记-复制）</p>
<ol>
<li>如果From空间足够，则回收eden区可回收的对象。</li>
<li>如果from内存空间不够，则把From空间存活的对象复制到To区，</li>
<li>如果TO区的内存空间也不够的话，则把To区存活的对象复制到老年代。</li>
</ol>
</li>
<li>
<p>如果老年代空间也不够（或者达到触发老年年垃圾回收条件的话）则触发一次full GC。</p>
</li>
</ul>
<h3 id="full-gc">Full GC 触发条件</h3>
<p>1、System.gc()方法的调用</p>
<p>此方法的调用是建议JVM进行Full GC,虽然只是建议而非一定,但很多情况下它会触发 Full GC,从而增加Full GC的频率,也即增加了间歇性停顿的次数。强烈影响系建议能不使用此方法就别使用，让虚拟机自己去管理它的内存，可通过通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc。</p>
<p>2、老年代空间不足</p>
<p>老年代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出如下错误：
java.lang.OutOfMemoryError: Java heap space
为避免以上两种状况引起的Full GC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。</p>
<p>3、永生区空间不足</p>
<p>JVM规范中运行时数据区域中的方法区，在HotSpot虚拟机中又被习惯称为永生代或者永生区，Permanet Generation中存放的为一些class的信息、常量、静态变量等数据，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下也会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出如下错误信息：
java.lang.OutOfMemoryError: PermGen space
为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。</p>
<p>4、CMS GC时出现promotion failed和concurrent mode failure</p>
<p>对于采用CMS进行老年代GC的程序而言，尤其要注意GC日志中是否有promotion failed和concurrent mode failure两种状况，当这两种状况出现时可能
会触发Full GC。
promotion failed是在进行Minor GC时，survivor space放不下、对象只能放入老年代，而此时老年代也放不下造成的；concurrent mode failure是在
执行CMS GC的过程中同时有对象要放入老年代，而此时老年代空间不足造成的（有时候“空间不足”是CMS GC时当前的浮动垃圾过多导致暂时性的空间不足触发Full GC）。
对措施为：增大survivor space、老年代空间或调低触发并发GC的比率，但在JDK 5.0+、6.0+的版本中有可能会由于JDK的bug29导致CMS在remark完毕
后很久才触发sweeping动作。对于这种状况，可通过设置-XX: CMSMaxAbortablePrecleanTime=5（单位为ms）来避免。</p>
<p>5、统计得到的Minor GC晋升到旧生代的平均大小大于老年代的剩余空间</p>
<p>这是一个较为复杂的触发情况，Hotspot为了避免由于新生代对象晋升到旧生代导致旧生代空间不足的现象，在进行Minor GC时，做了一个判断，如果之
前统计所得到的Minor GC晋升到旧生代的平均大小大于旧生代的剩余空间，那么就直接触发Full GC。
例如程序第一次触发Minor GC后，有6MB的对象晋升到旧生代，那么当下一次Minor GC发生时，首先检查旧生代的剩余空间是否大于6MB，如果小于6MB，
则执行Full GC。
当新生代采用PS GC时，方式稍有不同，PS GC是在Minor GC后也会检查，例如上面的例子中第一次Minor GC后，PS GC会检查此时旧生代的剩余空间是否
大于6MB，如小于，则触发对旧生代的回收。
除了以上4种状况外，对于使用RMI来进行RPC或管理的Sun JDK应用而言，默认情况下会一小时执行一次Full GC。可通过在启动时通过- java -
Dsun.rmi.dgc.client.gcInterval=3600000来设置Full GC执行的间隔时间或通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc。</p>
<p>6、堆中分配很大的对象</p>
<p>所谓大对象，是指需要大量连续内存空间的java对象，例如很长的数组，此种对象会直接进入老年代，而老年代虽然有很大的剩余空间，但是无法找到足够大的连续空间来分配给当前对象，此种情况就会触发JVM进行Full GC。
为了解决这个问题，CMS垃圾收集器提供了一个可配置的参数，即-XX:+UseCMSCompactAtFullCollection开关参数，用于在“享受”完Full GC服务之后额外免费赠送一个碎片整理的过程，内存整理的过程无法并发的，空间碎片问题没有了，但提顿时间不得不变长了，JVM设计者们还提供了另外一个参数 -XX:CMSFullGCsBeforeCompaction,这个参数用于设置在执行多少次不压缩的Full GC后,跟着来一次带压缩的。</p>
<h3 id="_13">内存分配策略</h3>
<ol>
<li>对象优先在Eden分配</li>
<li>大对象直接进入老年代</li>
<li>长期存活的对象将进入老年代：对象年龄达到设定值</li>
<li>动态对象年龄判定：如果Survivor空间中相同年龄所有对象的大小总和大于Survivor空间的一半，大于等于该年龄的对象进入老年代</li>
<li>空间分配担保：发生Minor GC之前，虚拟机会检查老年代的可用空间是否大于新生代所有对象的空间，条件成立则Minor GC是安全的</li>
</ol>
<h3 id="_14">内存布局</h3>
<p><img alt="内存布局" src="http://7xjtfr.com1.z0.glb.clouddn.com/06524e23ef9136970be290e3732c0066_thumb.jpg" /></p>
    </div>
    <div id="footer">
      <span>
        <p>Copyright © 2017 HanSong Xiao.
        Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1256629854'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/z_stat.php%3Fid%3D1256629854%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script></p>
        <p>Site Generated 2017-05-20 20:29:28</p>
      </span>
    </div>
  </body>
</html>