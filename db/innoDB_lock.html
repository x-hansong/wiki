<!DOCTYPE HTML>
<html>
  <head>
    <link rel="Stylesheet" type="text/css" href="/static/css/style.css">
    <link rel="Stylesheet" type="text/css" href="/static/css/tango.css">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Atom feed">
    <title>InnoDB的锁机制 - Wiki | HanSong</title>
    <meta name="keywords" content="wiki, markdown, linux, c, java, python, qemu"/>
    <meta name="description" content="HanSong's personal wiki, recording my little thoughts"/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  </head>

  <body>
    <div id="container">
      
<div id="header">
  <div class="post-nav"><a href="/">Home</a>&nbsp;&#187;&nbsp;<a href="/#db">db</a>&nbsp;&#187;&nbsp;InnoDB的锁机制
    <span class="updated">Updated&nbsp;
      2016-07-30
    </span></div>
</div>
<div class="clearfix"></div>

<div class="page_title">InnoDB的锁机制</div>

  <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#_1">锁的类型</a></li>
<li><a href="#intention-lock">意向锁（Intention Lock）</a></li>
<li><a href="#_2">锁的兼容性</a></li>
<li><a href="#_3">锁的粒度</a></li>
<li><a href="#innodb">InnoDB 行锁实现方式</a><ul>
<li><a href="#_4">行锁的三种算法</a></li>
</ul>
</li>
<li><a href="#_5">死锁</a></li>
<li><a href="#_6">阻塞</a></li>
</ul>
</div>
<h2 id="_1">锁的类型</h2>
<p>InnoDB 引擎实现了两种行级锁：</p>
<ul>
<li>
<p>共享锁（Shared Lock，简称S，也叫读锁）</p>
<p>表示对数据进行读操作。多个事务可同时为一个对象加共享锁，但阻止其他事务对同一对象加排它锁。</p>
</li>
<li>
<p>排他锁（Exclusive Lock，简称X，也叫写锁）</p>
<p>表示对数据进行写操作。如果一个事务对一个对象加了排他锁，那么其他事务就无法再给此对象加共享锁和排它锁。</p>
</li>
</ul>
<h2 id="intention-lock">意向锁（Intention Lock）</h2>
<p>为了方便检测表级锁和行级锁之间的冲突，减少加锁时封锁检查的工作量，支持多粒度的锁定，基于两种基本的锁类型，可以派生出如下两种意向锁：</p>
<ul>
<li>
<p>意向共享锁（IS）</p>
<p>事务打算给数据行加共享锁，事务在给一个数据行加共享锁前必须先给该表加上IS锁。</p>
</li>
<li>
<p>意向独占锁（IX）</p>
<p>事务打算给数据行加排他锁，事务在给一个数据行加排他锁前必须先给该表加上IX锁。</p>
</li>
</ul>
<p>意向锁主要目的是为了在一个事务中揭示下一行将被请求的锁类型。如果没意向锁，需要表锁时，要一行行检查某个表是否发生了行锁，进而判断能否表锁成功，如果有了意向锁，不用一个个去检查，直接从表的层次就可判断。</p>
<p>注：
1. 意向锁为表级锁，但表示的是事务正在操作某一行记录。
2. 意向锁之间不会发生冲突，冲突检测是在加行锁时发生。</p>
<h2 id="_2">锁的兼容性</h2>
<table>
<thead>
<tr>
<th>.</th>
<th>X</th>
<th>IX</th>
<th>S</th>
<th>IS</th>
</tr>
</thead>
<tbody>
<tr>
<td>X</td>
<td>冲突</td>
<td>冲突</td>
<td>冲突</td>
<td>冲突</td>
</tr>
<tr>
<td>IX</td>
<td>冲突</td>
<td>兼容</td>
<td>冲突</td>
<td>兼容</td>
</tr>
<tr>
<td>S</td>
<td>冲突</td>
<td>冲突</td>
<td>兼容</td>
<td>兼容</td>
</tr>
<tr>
<td>IS</td>
<td>冲突</td>
<td>兼容</td>
<td>兼容</td>
<td>兼容</td>
</tr>
</tbody>
</table>
<h2 id="_3">锁的粒度</h2>
<ul>
<li>
<p>表锁（Table Lock）</p>
<p>对整个表加锁，影响表的所有记录。通常用在DDL语句中，如ALTER、DROP、TRUNCATE等。</p>
</li>
<li>
<p>行锁（Row Lock）</p>
<p>对一行记录加锁，只影响一条记录。通常用在DML语句中，如INSERT、UPDATE、DELETE等。</p>
</li>
</ul>
<h2 id="innodb">InnoDB 行锁实现方式</h2>
<p>InnoDB 行锁是通过给索引上的索引项加锁来实现的，这一点 MySQL 与 Oracle 不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB 这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁。</p>
<h3 id="_4">行锁的三种算法</h3>
<ul>
<li>
<p>记录锁（Record Lock）</p>
<p>索引记录上的锁（基于B树叶子节点的锁）。</p>
</li>
<li>
<p>间隙锁（Gap Lock）</p>
<p>索引记录间隙上的锁，锁定一个范围区间，不包含记录本身。（即第一条索引记录之前或最后一条索记录之后或其它索引记录之间的空隙）</p>
</li>
<li>
<p>下一键锁（Next-key Lock）</p>
<p>索引的记录锁以及索引记录之间的间隙锁，即Record Lock + Gap Lock的组合锁。（即某个索引记录本身和该索引记录两边的空隙）
用于在 RR 隔离级别下解决幻读。</p>
</li>
</ul>
<p>例如，有索引列1,3,5三条记录:</p>
<ul>
<li>记录锁会锁住1、3、5的记录本身；</li>
<li>间隙锁则锁住(-∞,1)、(1,3)、(3,5)、(5,+∞)区间；</li>
<li>下一键锁则是(-∞,1]、(1,3]、(3,5]、(5,+∞)区间。</li>
</ul>
<p>注：</p>
<ol>
<li>如果表中没有任何索引，此时InnoDB会自动创建一个隐式聚集索引，并用这个索引来加记录锁。</li>
<li>InnoDB 对唯一索引加 Record Lock，其他情况加 Next-key Lock</li>
<li>Gap Lock中存在一种插入意向锁（Insert Intention Lock），在insert操作时产生。在多事务同时写入不同数据至同一索引间隙的时候，并不需要等待其他事务完成，不会发生锁等待。假设有一个记录索引包含键值4和7，不同的事务分别插入5和6，每个事务都会产生一个加在4-7之间的插入意向锁，获取在插入行上的排它锁，但是不会被互相锁住，因为数据行并不冲突。</li>
<li>
<p>在默认innodb是RR隔离级别，并且参数innodb_locks_unsafe_for_binlog被禁止情况下：</p>
<ol>
<li>非唯一索引会产生Next-key Lock，即Record Lock + Gap Lock。可防止幻读；</li>
<li>如果操作（update、delete）的列没有索引，所有纪录加上Next-key Lock，即所有的行记录都被锁住，相当于全表锁，此时相关此表的任何操作都将被阻塞；</li>
<li>修改事务隔离级别为RC或启用innodb_locks_unsafe_for_binlog参数，InnoDB会触发semi-consistent read，降低锁范围，变成只锁定有影响的记录行。（风险：违反二阶段锁（2PL）原则，导致幻读，不可重复读）</li>
</ol>
</li>
</ol>
<h2 id="_5">死锁</h2>
<p>死锁指两个或以上事务因争夺锁资源造成互相等待。解决方式：</p>
<ol>
<li>超时机制：事务等待超时即回滚。</li>
<li>wait-for graph（等待图）进行死锁检测，通过保存锁的信息链表和事务等待链表，然后构造等待图。在每个事务请求锁并发等待的时候都会判断是否存在回路，若存在死锁，InnoDB会回滚undo量最小的事务。</li>
</ol>
<h2 id="_6">阻塞</h2>
<p>阻塞即一个事务的锁需要等待其他事务的锁释放资源。</p>
<p>在InnoDB存储引擎中，参数innodb_lock_wait_timeout用来控制等待的时间（默认是50秒），innodb_rollback_on_timeout用来设定
是否在等待超时时对进行中的事务进行回滚操作（默认是OFF，代表不回滚）。参数innodb_lock_wait_timeout是动态的，可以在MySQ
L数据库运行时进行调整。</p>
<p>在默认情况下InnoDB不会回滚超时引发的错误异常，因此用户必须判断是否进行提交或者回滚。但是如果检测到死锁发生，InnoDB会马上回滚事务。</p>
    </div>
    <div id="footer">
      <span>
        <p>Copyright © 2017 HanSong Xiao.
        Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1256629854'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/z_stat.php%3Fid%3D1256629854%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script></p>
        <p>Site Generated 2017-07-16 23:42:46</p>
      </span>
    </div>
  </body>
</html>