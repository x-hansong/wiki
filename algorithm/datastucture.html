<!DOCTYPE HTML>
<html>
  <head>
    <link rel="Stylesheet" type="text/css" href="/static/css/style.css">
    <link rel="Stylesheet" type="text/css" href="/static/css/tango.css">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Atom feed">
    <title>数据结构 - Wiki | HanSong</title>
    <meta name="keywords" content="wiki, markdown, linux, c, java, python, qemu"/>
    <meta name="description" content="HanSong's personal wiki, recording my little thoughts"/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  </head>

  <body>
    <div id="container">
      
<div id="header">
  <div class="post-nav"><a href="/">Home</a>&nbsp;&#187;&nbsp;<a href="/#algorithm">algorithm</a>&nbsp;&#187;&nbsp;数据结构
    <span class="updated">Updated&nbsp;
      2016-02-23
    </span></div>
</div>
<div class="clearfix"></div>

<div class="page_title">数据结构</div>

  <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#_1">栈</a><ul>
<li><a href="#_2">相关应用</a></li>
</ul>
</li>
<li><a href="#_3">树</a><ul>
<li><a href="#_4">基本概念</a></li>
<li><a href="#_5">二叉树</a><ul>
<li><a href="#_6">应用</a></li>
</ul>
</li>
<li><a href="#_7">哈夫曼树</a></li>
<li><a href="#_8">二叉搜索树</a></li>
<li><a href="#avl">AVL 树</a><ul>
<li><a href="#_9">旋转</a></li>
</ul>
</li>
<li><a href="#_10">红黑树</a></li>
<li><a href="#b-tree">B-tree</a></li>
<li><a href="#b-tree_1">B+-tree</a></li>
</ul>
</li>
<li><a href="#_11">哈希</a><ul>
<li><a href="#_12">冲突解决</a></li>
</ul>
</li>
<li><a href="#_13">优先队列</a><ul>
<li><a href="#_14">二叉堆（基于数组）</a></li>
<li><a href="#d">d 叉堆</a></li>
<li><a href="#_15">左式堆</a></li>
</ul>
</li>
<li><a href="#_16">图</a><ul>
<li><a href="#_17">拓扑排序</a></li>
<li><a href="#_18">最短路径</a></li>
<li><a href="#_19">网络流问题</a></li>
<li><a href="#_20">最小生成树</a></li>
</ul>
</li>
</ul>
</div>
<h2 id="_1">栈</h2>
<h3 id="_2">相关应用</h3>
<ol>
<li>括号匹配。</li>
<li>
<p>中缀转后缀表达式</p>
<div class="hlcode"><pre><span class="err">进行中缀转后缀操作，使用符号栈存储遍历过程中遇到的符号。</span>
<span class="err">从左到右遍历中缀表达式，遇到数字直接输出，遇到符号准备将其放入符号栈：</span>
<span class="err">若符号栈为空，直接放入。</span>
<span class="err">若当前符号大于栈顶符号优先级，直接放入。</span>
<span class="err">如果小于等于栈顶符号优先级，将栈顶符号弹出，直到栈顶符号小于当前符号，再将当前符号入栈。</span>
<span class="err">如果当前符号为“（”，直接入栈。</span>
<span class="err">如果当前符号为“）”，依次将符号栈的符号弹出，直到找到“（”。</span>
<span class="err">按此规则进行遍历，最后如果符号栈仍有符号，弹出即可。</span>
</pre></div>


</li>
<li>
<p>后缀表达式计算</p>
<div class="hlcode"><pre><span class="err">遇到数字入栈</span>
<span class="err">遇到符号：弹出两个数字，计算后把结果存入栈</span>
</pre></div>


</li>
</ol>
<h2 id="_3">树</h2>
<h3 id="_4">基本概念</h3>
<ul>
<li><strong>path</strong>：node n1 to nk is defined as a sequence of nodes n1, n2, . . . , nk such that ni is the parent of ni+1 for 1 ≤ i &lt; k.</li>
<li><strong>length</strong>：The length of this path is the number of edges on the path, namely k − 1.</li>
<li><strong>depth</strong>：For any node ni, the depth of ni is the length of the unique path from the root to ni. The depth of a tree is equal to the depth of the deepest leaf.</li>
<li><strong>height</strong>：The height of ni is the length of the longest path from ni to a leaf. Thus all leaves are at height 0. The height of a tree is equal to the height of the root.</li>
<li>Conventionally, an empty tree (tree with no nodes, if such are allowed) has depth and height −1.</li>
</ul>
<p>上面的定义来自《Data Structures and Algorithm Analysis》，下面的定义来自国内教材。</p>
<p>树的深度是从根节点开始（其深度为1）自顶向下逐层累加的，而高度是从叶节点开始（其高度为1）自底向上逐层累加的。虽然树的深度和高度一样，但是具体到树的某个节点，其深度和高度是不一样的。</p>
<p>也就是说根节点的深度，叶子节点的高度有两种不同的初始值，有些定义为0，有些定义为1。</p>
<h3 id="_5">二叉树</h3>
<ul>
<li><strong>满二叉树</strong>：所有节点都有0或者2个孩子。</li>
<li><strong>完全二叉树</strong>：除了最后一层从左到右填充，其他层都是完全满的。
    完全二叉树的性质：n = 2^h+1 - 1 (此时叶子节点的高度定义为0)</li>
</ul>
<h4 id="_6">应用</h4>
<ul>
<li>表达式树：通过栈构建表达式树</li>
</ul>
<h3 id="_7">哈夫曼树</h3>
<div class="hlcode"><pre><span class="mf">1.</span> <span class="err">为每个符号建立一个叶子节点，并加上其相应的发生频率</span>
<span class="mf">2.</span> <span class="err">当有一个以上的节点存在时，进行下列循环</span><span class="o">:</span>
    <span class="mf">1.</span> <span class="err">把这些节点作为带权值的二叉树的根节点，左右子树为空</span>
    <span class="mf">2.</span> <span class="err">选择两棵根结点权值最小的树作为左右子树构造一棵新的二叉树，且至新的二叉树的根结点的权值为其左右子树上根结点的权值之和。</span>
    <span class="mf">3.</span> <span class="err">把权值最小的两个根节点移除</span>
    <span class="mf">4.</span> <span class="err">将新的二叉树加入队列中</span><span class="p">.</span>
<span class="mf">3.</span> <span class="err">最后剩下的节点暨为根节点，此时二叉树已经完成。</span>
</pre></div>


<h3 id="_8">二叉搜索树</h3>
<p>左子树小于右子树.
二叉查找树的一般操作的执行时间为O(lgn)。但二叉查找树若退化成了一棵具有n个结点的线性链后，则这些操作最坏情况运行时间为O(n)。</p>
<h3 id="avl">AVL 树</h3>
<p>即自平衡的二叉搜索树。AVL树中任何节点的两个子树的高度最大差别为 1，这样可以使二叉搜索的深度保持 log(n) 的深度，这样节点分布相对均匀，可以使搜索的时间复杂度是 log(n)</p>
<h4 id="_9">旋转</h4>
<p>有四种情况导致 AVL 树失衡：</p>
<ol>
<li>An insertion into the left subtree of the left child of α. (LL)</li>
<li>An insertion into the right subtree of the left child of α. (RL)</li>
<li>An insertion into the left subtree of the right child of α. (LR)</li>
<li>An insertion into the right subtree of the right child of α. (RR)</li>
</ol>
<p>其中，LL，RR只需要一次旋转，LR，RL 需要两次旋转</p>
<h3 id="_10">红黑树</h3>
<p>红黑树，一种二叉查找树，但在每个结点上增加一个存储位表示结点的颜色，可以是Red或Black。
通过对任何一条从根到叶子的路径上各个结点着色方式的限制，红黑树确保没有一条路径会比其他路径长出俩倍，因而是接近平衡的。可以在O(log n)时间内做查找，插入和删除。</p>
<p>红黑树是 2-3 树的一种等同。换句话说，对于每个 2-3 树，都存在至少一个数据元素是同样次序的红黑树。在 2-3 树上的插入和删除操作也等同于在红黑树中颜色翻转和旋转。这使得 2-3 树成为理解红黑树背后的逻辑的重要工具，这也是很多介绍算法的教科书在红黑树之前介绍 2-3 树的原因，尽管 2-3 树在实践中不经常使用。</p>
<p>红黑树与 2-3 树的等价定义：</p>
<ul>
<li>Red links lean left.</li>
<li>No node has two red links connected to it.</li>
<li>The tree has perfect black balance : every path from the root to a null link has the
same number of black links</li>
</ul>
<p>AVL 树和红黑树的比较</p>
<ol>
<li>如果插入一个node引起了树的不平衡，AVL和RB-Tree都是最多只需要2次旋转操作，即两者都是O(1)；但是在删除node引起树的不平衡时，最坏情况下，AVL需要维护从被删node到root这条路径上所有node的平衡性，因此需要旋转的量级O(logN)，而RB-Tree最多只需3次旋转，只需要O(1)的复杂度。</li>
<li>其次，AVL的结构相较RB-Tree来说更为平衡，在插入和删除node更容易引起Tree的unbalance，因此在大量数据需要插入或者删除时，AVL需要rebalance的频率会更高。因此，RB-Tree在需要大量插入和删除node的场景下，效率更高。自然，由于AVL高度平衡，因此AVL的search效率更高。</li>
<li>map的实现只是折衷了两者在search、insert以及delete下的效率。总体来说，RB-tree的统计性能是高于AVL的。</li>
</ol>
<p>另一种红黑树定义：</p>
<ol>
<li>节点是红色或黑色。</li>
<li>根是黑色。</li>
<li>所有叶子都是黑色（叶子是NIL节点）。</li>
<li>每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</li>
<li>从任一节点到其每个叶子的所有简单路径 都包含相同数目的黑色节点。</li>
</ol>
<h3 id="b-tree">B-tree</h3>
<p>According to Knuth's definition, a B-tree of order m is a tree which satisfies the following properties:</p>
<ul>
<li>Every node has at most m children.</li>
<li>Every non-leaf node (except root) has at least [m/2] children.</li>
<li>The root has at least two children if it is not a leaf node.</li>
<li>A non-leaf node with k children contains k−1 keys.</li>
<li>All leaves appear in the same level</li>
</ul>
<h3 id="b-tree_1">B+-tree</h3>
<p>B+-tree ：是应文件系统所需而产生的一种B-tree的变形树。</p>
<p>A B+ tree can be viewed as a B-tree in which each node contains only keys (not key-value pairs), and to which an additional level is added at the bottom with linked leaves.</p>
<p><strong>为什么说B+-tree比B 树更适合实际应用中操作系统的文件索引和数据库索引？</strong></p>
<ol>
<li>
<p>B+-tree的磁盘读写代价更低</p>
<p>B+-tree的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。
举个例子，假设磁盘中的一个盘块容纳16bytes，而一个关键字2bytes，一个关键字具体信息指针2bytes。一棵9阶B-tree(一个结点最多8个关键字)的内部结点需要2个盘快。而B+ 树内部结点只需要1个盘快。当需要把内部结点读入内存中的时候，B 树就比B+ 树多一次盘块查找时间(在磁盘中就是盘片旋转的时间)。</p>
</li>
<li>
<p>B+-tree的查询效率更加稳定</p>
<p>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>
</li>
</ol>
<p><strong>B+-tree的应用:</strong> VSAM(虚拟存储存取法)文件</p>
<h2 id="_11">哈希</h2>
<h3 id="_12">冲突解决</h3>
<ol>
<li>链接法（开散列）：使用链表存储相同哈希值的值</li>
<li>开发定址法（闭散列）<ol>
<li>线性探测散列：消除冲突，产生一次聚集</li>
<li>二次探测散列：消除一次聚集，产生二次聚集</li>
<li>双重哈希</li>
</ol>
</li>
</ol>
<h2 id="_13">优先队列</h2>
<h3 id="_14">二叉堆（基于数组）</h3>
<p>从 1 下标开始，对于每个 i，左孩子是 2i，右孩子是 2i+1，父节点是 i/2。</p>
<p>插入通过上滤调整堆，删除通过下滤调整堆。</p>
<h3 id="d">d 叉堆</h3>
<h3 id="_15">左式堆</h3>
<h2 id="_16">图</h2>
<p>实现：邻接链表，邻接矩阵</p>
<h3 id="_17">拓扑排序</h3>
<ul>
<li>
<p>Kahn算法</p>
<ol>
<li>从 DAG 图中选择一个 没有前驱（即入度为0）的顶点并输出。</li>
<li>从图中删除该顶点和所有以它为起点的有向边。</li>
<li>重复 1 和 2 直到当前的 DAG 图为空或当前图中不存在无前驱的顶点为止。后一种情况说明有向图中必然存在环。</li>
</ol>
</li>
<li>
<p>DFS</p>
<div class="hlcode"><pre><span class="nx">L</span> <span class="err">←</span> <span class="nx">Empty</span> <span class="nx">list</span> <span class="nx">that</span> <span class="nx">will</span> <span class="nx">contain</span> <span class="nx">the</span> <span class="nx">sorted</span> <span class="nx">nodes</span>
<span class="nx">S</span> <span class="err">←</span> <span class="nx">Set</span> <span class="nx">of</span> <span class="nx">all</span> <span class="nx">nodes</span> <span class="kd">with</span> <span class="nx">no</span> <span class="nx">outgoing</span> <span class="nx">edges</span>
<span class="k">for</span> <span class="nx">each</span> <span class="nx">node</span> <span class="nx">n</span> <span class="k">in</span> <span class="nx">S</span> <span class="k">do</span>
    <span class="nx">visit</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
<span class="kd">function</span> <span class="nx">visit</span><span class="p">(</span><span class="nx">node</span> <span class="nx">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">n</span> <span class="nx">has</span> <span class="nx">not</span> <span class="nx">been</span> <span class="nx">visited</span> <span class="nx">yet</span> <span class="nx">then</span>
        <span class="nx">mark</span> <span class="nx">n</span> <span class="nx">as</span> <span class="nx">visited</span>
        <span class="k">for</span> <span class="nx">each</span> <span class="nx">node</span> <span class="nx">m</span> <span class="kd">with</span> <span class="nx">an</span> <span class="nx">edge</span> <span class="nx">from</span> <span class="nx">m</span> <span class="nx">to</span> <span class="nx">ndo</span>
            <span class="nx">visit</span><span class="p">(</span><span class="nx">m</span><span class="p">)</span>
        <span class="nx">add</span> <span class="nx">n</span> <span class="nx">to</span> <span class="nx">L</span>
</pre></div>


</li>
</ul>
<h3 id="_18">最短路径</h3>
<ul>
<li>
<p>Dijkstra算法</p>
<p>dijkstra算法用来计算从一个点到其他所有点的最短路径的算法，复杂度O(N2)。</p>
</li>
<li>
<p>Floyd算法</p>
<p>floyd算法是最简单的最短路径算法，可以计算图中任意两点间的最短路径  folyd算法的时间复杂度是O(N3),如果是一个没有边权的图，把相连的两点  间的距离设为dist[i][j] = 1，不相连的两点设为无穷大，用 floyd算法可以判断i,j两点是否有路径相连。</p>
</li>
</ul>
<h3 id="_19">网络流问题</h3>
<h3 id="_20">最小生成树</h3>
<ul>
<li>
<p>Prim 算法</p>
<ol>
<li>清空生成树，任取一个顶点加入生成树</li>
<li>在那些一个端点在生成树里，另一个端点不在生成树里的边中，选取一条权最小的边，将它和另一个端点加进生成树</li>
<li>重复步骤2，直到所有的顶点都进入了生成树为止，此时的生成树就是最小生成树</li>
</ol>
</li>
<li>
<p>Kruskal算法</p>
<p>构造一个只含n个顶点，而边集为空的子图，若将该子图中各个顶点看成是各棵树的根节点，则它是一个含有n棵树的森林 。之后，从网的边集中选取一条权值最小的边，若该边的两个顶点分属不同的树 ，则将其加入子图，也就是这两个顶点分别所在的 两棵树合成一棵树；反之，若该边的两个顶点已落在同一棵树上，则不可取，而应该取下一条权值最小的边再试之。依次类推，直至森林只有一棵树。</p>
</li>
</ul>
    </div>
    <div id="footer">
      <span>
        <p>Copyright © 2017 HanSong Xiao.
        Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1256629854'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s11.cnzz.com/z_stat.php%3Fid%3D1256629854%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script></p>
        <p>Site Generated 2017-05-18 00:05:23</p>
      </span>
    </div>
  </body>
</html>